### **1.**inline**이란 무엇인가?**

`inline` 키워드는 컴파일러에게 "이 함수를 호출하는 곳(Call site)에 함수 본문 코드를 그대로 '복사-붙여넣기' 해라"라고 지시하는 명령어입니다.

일반적인 함수 호출은 코드 실행 흐름이 해당 함수의 메모리 주소로 이동(Jump)했다가 다시 돌아오는 과정(스택 메모리 생성 등)을 거치지만,`inline`함수는 호출 지점에 코드가 심어지기 때문에 함수 호출 과정이 생략됩니다.

---

### **2. 왜 사용하는가? (목적: 성능 최적화)**

코틀린에서 함수는 객체(First-class citizen)로 취급됩니다. 특히 함수를 파라미터로 넘기는 고차 함수(람다식)를 사용할 때, JVM 상에서는 다음과 같은 오버헤드가 발생합니다.

1. **객체 생성 오버헤드**: 람다식은 컴파일되면 익명 클래스(Function 객체)로 변환되어 힙 메모리에 할당됩니다. 호출될 때마다 객체가 생성될 수 있습니다.
2. **가상 호출 오버헤드**: 함수를 호출할 때 추가적인 메서드 호출 비용이 듭니다.

inline을 사용하면 람다식 객체를 생성하지 않고, **람다의 본문 코드를 호출 지점에 직접 삽입**해버리기 때문에 이러한 오버헤드를 없앨 수 있습니다.

---

### **3. 동작 원리 (코드 비교)**

**A.**inline** 미사용 시 (일반적인 동작)**

```kotlin
fun doSomething(block: () -> Unit) {
    println("Before")
    block()
    println("After")
}

fun main() {
    doSomething { println("Inside") }
}
```

- **컴파일 결과(가상)**: doSomething을 호출할 때 Function 객체(`new Function() {...}`)가 생성되어 전달됩니다.

**B.**inline**사용 시**

```kotlin
inline fun doSomething(block: () -> Unit) {
    println("Before")
    block()
    println("After")
}

fun main() {
    doSomething { println("Inside") }
}
```

- **컴파일 결과(가상)**: 함수 호출이 사라지고 코드가 그대로 박힙니다.

```kotlin
fun main() {
    println("Before")
    println("Inside") // 람다의 내용이 그대로 복사됨
    println("After")
}
```

---

### **4. 관련 주요 키워드 (**noinline**, **crossinline**,**reified**)**

면접에서는 inline만 물어보기보다 이 파생 키워드들을 아는지 확인하는 경우가 많습니다.

### **1)** noinline

인자로 받는 람다가 여러 개일 때, **특정 람다는 인라인 처리하고 싶지 않을 때** 사용합니다.

- **이유**: 인라인 된 람다는 객체가 아니므로, 다른 함수에 변수처럼 전달하거나 리턴할 수 없습니다. 람다를 변수처럼 다뤄야 한다면 `noinline`을 붙여야 합니다.

```kotlin
inline fun test(inlined: () -> Unit, noinline notInlined: () -> Unit) {
    inlined() // 코드가 복사됨
    someOtherFunction(notInlined) // 객체로 전달 가능
}
```

### **2)** crossinline

이것은 "비지역 반환(Non-local return)을 금지"할 때 사용합니다.

- **배경**: inline 함수 내부의 람다에서는 return을 쓰면 람다만 종료되는 게 아니라, **그 람다를 호출한 바깥 함수(main 등)까지 종료**되어 버립니다. (코드가 복사되었기 때문)
- **문제**: 만약 람다가 다른 스레드나 UI 콜백 같은 컨텍스트(간접 호출)에서 실행된다면, 바깥 함수를 종료시키는 것이 위험하거나 불가능할 수 있습니다.
- **해결**: crossinline을 붙이면 "이 람다 안에서는 return을 써서 바깥 함수를 종료하지 마!"라고 강제합니다.

### **3)** reified

inline 함수에서만 사용할 수 있는 강력한 기능입니다.

- **문제**: 제네릭 T는 런타임에 타입이 지워집니다(Type Erasure).
- **해결**: inline은 코드를 복사해 넣기 때문에, 컴파일 시점에 **실제 타입이 무엇인지 알 수 있습니다.** reified 키워드를 쓰면 런타임에도 `T::class.java` 처럼 타입 클래스에 접근할 수 있습니다.

---

### **5. 단점 및 주의사항 (언제 쓰면 안 되나?)**

"그럼 모든 함수에 inline을 붙이면 좋은가요?" -> **절대 아닙니다.**

1. **코드 크기 증가 (Code Bloat)**: 함수 본문이 호출하는 모든 곳에 복사되므로, 함수 내용이 길거나 호출하는 곳이 많으면 컴파일된 바이트코드 크기가 급격히 커질 수 있습니다.
2. **람다가 없는 함수**: 람다(고차 함수)를 파라미터로 받지 않는 일반 함수는 JVM의 JIT 컴파일러가 알아서 최적화를 잘 해줍니다. 굳이 inline을 붙여서 얻을 이득은 없고 코드 크기만 늘어납니다.
3. **private 멤버 접근 불가**: inline 함수는 호출 지점에 복사되므로, 해당 클래스의 private 멤버에 접근할 수 없습니다. (캡슐화 위배 방지)

---

### **요약**

> "inline 키워드는 고차 함수 사용 시 발생하는 람다 객체 생성 오버헤드와 가상 호출 비용을 줄이기 위해 사용합니다. 컴파일러가 함수의 본문 코드를 호출 지점에 그대로 복사해 넣는 방식으로 동작합니다.
>
>
> 또한, 제네릭에서 reified **키워드를 사용하여 런타임에 타입 정보를 알아내기 위해서도 필수적으로 사용**됩니다.
>
> 하지만 무분별하게 사용하면 **코드 사이즈가 커지는 부작용**이 있으므로, 주로 람다를 파라미터로 받는 작고 빈번하게 호출되는 유틸리티성 함수에 사용하는 것이 적합합니다."
>